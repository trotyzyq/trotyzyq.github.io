<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>学习</title>
      <link href="/2019/03/25/%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/03/25/%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="系统调试"><a href="#系统调试" class="headerlink" title="系统调试"></a>系统调试</h2><h3 id="服务器服务不可用，你会如何怎么做？"><a href="#服务器服务不可用，你会如何怎么做？" class="headerlink" title="服务器服务不可用，你会如何怎么做？"></a>服务器服务不可用，你会如何怎么做？</h3><ol><li>检查dns是否可用，是否到了负载均衡那一层,可以通过查看日志<br><a href="http://www.cnblogs.com/zhuoqingsen/p/10200813.html?utm_source=gold_browser_extension" target="_blank" rel="noopener">链接</a></li><li>如果到了应用服务器那一层，服务不可用一般是因为进程挂了，可以查看进程是否存在。<h3 id="服务器响应变得很慢，你会怎么做？"><a href="#服务器响应变得很慢，你会怎么做？" class="headerlink" title="服务器响应变得很慢，你会怎么做？"></a>服务器响应变得很慢，你会怎么做？</h3>一般都是代码的bug,导致cpu占用很高，从而导致jvm内存疯狂提高，full gc<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3></li><li>理解微服务的优点和缺点<br><a href="https://www.cnblogs.com/exceptioneye/p/9334303.html" target="_blank" rel="noopener">微服务架构实践链接</a>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">开发效率低：所有的开发在一个项目改代码，递交代码相互等待，代码冲突不断</span><br><span class="line">代码维护难：代码功能耦合在一起，新人不知道何从下手</span><br><span class="line">部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长</span><br><span class="line">稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉</span><br><span class="line">扩展性不够：无法满足高并发情况下的业务需求</span><br><span class="line"></span><br><span class="line">服务之间的发现、服务调用链的跟踪和质量问题变得的相当棘手</span><br><span class="line"><span class="built_in">CAP</span>原理的约束，使得我们不得不放弃传统的强一致性，而转而追求最终一致性</span><br><span class="line">分布式事务，分布式锁问题</span><br></pre></td></tr></table></figure></li></ol><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="为什么Redis要用单线程"><a href="#为什么Redis要用单线程" class="headerlink" title="为什么Redis要用单线程"></a>为什么Redis要用单线程</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">减少<span class="meta">cpu</span>上下文切换</span><br><span class="line">单线程不会有线程安全问题</span><br></pre></td></tr></table></figure><h3 id="为什么不用redis做消息队列"><a href="#为什么不用redis做消息队列" class="headerlink" title="为什么不用redis做消息队列"></a>为什么不用redis做消息队列</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>redis吞吐量高，速度快，但是消息并不可靠</span><br></pre></td></tr></table></figure><ol start="3"><li>项目中遇到的问题</li><li>如果线上出问题，你首先会怎么做？</li><li>java的工具除了javac，你还用过哪些？<h3 id="redis事务支持吗？"><a href="#redis事务支持吗？" class="headerlink" title="redis事务支持吗？"></a>redis事务支持吗？</h3></li><li>redis支持事务，不过在集群环境下key会分配到不同的节点，所以事务机制不会生效。</li><li>redis事务不支持回滚，如同鸡肋。</li></ol><h3 id="redis多数据库知道吗？"><a href="#redis多数据库知道吗？" class="headerlink" title="redis多数据库知道吗？"></a>redis多数据库知道吗？</h3><ol><li>redis多数据库只在单机环境下有效，默认都是存放在db0的。</li><li>它并不是完全隔离的，在flushall的情况下，会将16个数据库的数据给全部清除。 </li></ol><h3 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h3><p><a href="https://www.cnblogs.com/rjzheng/p/10360619.html" target="_blank" rel="noopener">redis集群</a></p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h3><h4 id="ip-hash是什么"><a href="#ip-hash是什么" class="headerlink" title="ip_hash是什么"></a>ip_hash是什么</h4><p>解释:同一个IP,会被一直转到对应的服务器<br>优点：如果没有做session共享，被转到其他服务器后，session信息会消失。<br>缺点：负载均衡上出现问题。 </p><h4 id="ip-hash原理"><a href="#ip-hash原理" class="headerlink" title="ip_hash原理"></a>ip_hash原理</h4><p>类似于除留余数法。<br>原因：去掉一个需要标记为down,而不是删除</p><h4 id="ip-hash服务器列表中去掉服务器，应该怎么做"><a href="#ip-hash服务器列表中去掉服务器，应该怎么做" class="headerlink" title="ip_hash服务器列表中去掉服务器，应该怎么做"></a>ip_hash服务器列表中去掉服务器，应该怎么做</h4><p><code>标记</code>：应该标记为<code>down</code>,而不是删除</p><h2 id="Jvm"><a href="#Jvm" class="headerlink" title="Jvm"></a>Jvm</h2><h3 id="为什么xms和xmx设置成一样？"><a href="#为什么xms和xmx设置成一样？" class="headerlink" title="为什么xms和xmx设置成一样？"></a>为什么xms和xmx设置成一样？</h3><p>答：为了防止堆自动扩展</p><h3 id="为什么防止堆自动扩展"><a href="#为什么防止堆自动扩展" class="headerlink" title="为什么防止堆自动扩展"></a>为什么防止堆自动扩展</h3><p>答：扩展一次必定影响当时性能，而且它的扩展可能和hashmap类似</p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><ol><li>常量类和枚举类都会在类初始化的时候加载常量。</li><li>为什么可以修改静态变量，不是只加载一次吗？<br>答：后边几次的修改，只是修改了引用关系而已。<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="JVM中survivor区存在的意义是啥"><a href="#JVM中survivor区存在的意义是啥" class="headerlink" title="JVM中survivor区存在的意义是啥"></a>JVM中survivor区存在的意义是啥</h4>如果只有一个eden区，gc后会存在内存碎片。<br>如果只有一个survivor,gc后eden和sur同样会存在碎片。<br>如果有两个sur后，可以直接全部复制过去。<br>参考：<br><a href="http://blog.csdn.net/antony9118/article/details/51425581" target="_blank" rel="noopener">为什么新生代内存需要有两个Survivor区</a><h3 id="jdk工具"><a href="#jdk工具" class="headerlink" title="jdk工具"></a>jdk工具</h3><h4 id="jstat-查看gc情况，jvm内存使用情况"><a href="#jstat-查看gc情况，jvm内存使用情况" class="headerlink" title="jstat 查看gc情况，jvm内存使用情况"></a>jstat 查看gc情况，jvm内存使用情况</h4><code>jstat -gcutil &#39;java进程PID&#39; 1000</code><h3 id="异常问题"><a href="#异常问题" class="headerlink" title="异常问题"></a>异常问题</h3><h4 id="OOM后程序还会执行吗"><a href="#OOM后程序还会执行吗" class="headerlink" title="OOM后程序还会执行吗"></a>OOM后程序还会执行吗</h4>答：可以的。<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3>优点：复制之后的内存会是连续的。</li></ol><h2 id="RabbitMq"><a href="#RabbitMq" class="headerlink" title="RabbitMq"></a>RabbitMq</h2><h3 id="几种模式"><a href="#几种模式" class="headerlink" title="几种模式"></a>几种模式</h3><ol><li>redirct，topic,Fanout Exchange<h3 id="监听消息队列的服务最重要的几件事"><a href="#监听消息队列的服务最重要的几件事" class="headerlink" title="监听消息队列的服务最重要的几件事"></a>监听消息队列的服务最重要的几件事</h3></li><li>消息确认</li><li>消息入库，确保幂等性<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li>不支持优先级，但是可以可以用业务代码解决这个问题</li></ol><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p><code>distinct</code>一般是用来查询没有重复的记录数量的，若是需要查询不重复的记录，可以用<code>group by</code> <a href="https://www.cnblogs.com/shiluoliming/p/6604407.html" target="_blank" rel="noopener">链接</a></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="为什么Innodb-不建议索引很长"><a href="#为什么Innodb-不建议索引很长" class="headerlink" title="为什么Innodb 不建议索引很长"></a>为什么Innodb 不建议索引很长</h4><p>InnoDB辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录，从而能够明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</p><h4 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、当使用or的情况下，如果不是每一列的条件都有索引，索引失效 </span><br><span class="line"><span class="number">2</span>、当使用多列索引的时候，没有匹配到第一部分，索引失效 </span><br><span class="line"><span class="number">3</span>、当使用like的时候，以%开头，索引失效 </span><br><span class="line"><span class="number">4</span>、当数据类型是字符串类型的时候，如果条件数据没有被引号引起来，索引失效 </span><br><span class="line"><span class="number">5</span>、如果使用全表扫描比索引更快，索引失效</span><br></pre></td></tr></table></figure><h4 id="什么是聚集索引"><a href="#什么是聚集索引" class="headerlink" title="什么是聚集索引"></a>什么是聚集索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">聚集索引：将表内的数据按照一定的规则进行排列的目录。正因为如此，一个表中的聚焦索引只有一个。</span><br></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">悲观锁的特点是先获取锁，再进行业务操作。</span><br><span class="line">乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的。</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/zhiqian-ali/p/6200874.html" target="_blank" rel="noopener">解释一</a><br><a href="https://www.cnblogs.com/laoyeye/p/8097684.html" target="_blank" rel="noopener">乐观锁的实现</a></p><h4 id="InnoDB是什么锁"><a href="#InnoDB是什么锁" class="headerlink" title="InnoDB是什么锁"></a>InnoDB是什么锁</h4><p><a href="https://www.cnblogs.com/aipiaoborensheng/p/5767459.html" target="_blank" rel="noopener">链接</a><br>InnoDB是行锁，但是InnoDB行锁是通过给索引上的索引项加锁来实 现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索 数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ </p><h2 id="java-并发编程"><a href="#java-并发编程" class="headerlink" title="java 并发编程"></a>java 并发编程</h2><h3 id="什么是volatile"><a href="#什么是volatile" class="headerlink" title="什么是volatile"></a>什么是volatile</h3><p>在多核Cpu下，多个线程会有一个高速缓存。volatile 修饰的变量，在进行修改变量修改时，会直接修改主存，使其拥有可见性。</p><h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>volatile修饰的变量，如果访问这个变量，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="你会的命令"><a href="#你会的命令" class="headerlink" title="你会的命令"></a>你会的命令</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.top</span> </span><br><span class="line"><span class="number">2</span><span class="selector-class">.ls</span> </span><br><span class="line"><span class="number">3</span>.mkdir</span><br><span class="line"><span class="number">4</span>.touch</span><br><span class="line"><span class="number">5</span>.cat</span><br><span class="line"><span class="number">6</span>.chmod</span><br><span class="line"><span class="number">7</span><span class="selector-class">.ps</span> -ef</span><br><span class="line"><span class="number">8</span>.netstat</span><br><span class="line"><span class="number">9</span><span class="selector-class">.df</span> -h</span><br><span class="line"><span class="number">10</span>. ifconfig</span><br><span class="line"><span class="number">11</span> lsof -<span class="selector-tag">i</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">12</span>.nohup</span><br></pre></td></tr></table></figure><h2 id="NIO和Netty"><a href="#NIO和Netty" class="headerlink" title="NIO和Netty"></a>NIO和Netty</h2><h3 id="NIO中的缓冲区？"><a href="#NIO中的缓冲区？" class="headerlink" title="NIO中的缓冲区？"></a>NIO中的缓冲区？</h3><p>从channel中读取的码流数据最终都会到缓冲区中，同时Channel和ByteBuffer是1对1 的</p><h3 id="NIO的同步非阻塞体现在哪里？"><a href="#NIO的同步非阻塞体现在哪里？" class="headerlink" title="NIO的同步非阻塞体现在哪里？"></a>NIO的同步非阻塞体现在哪里？</h3><ol><li>同步体现在数据先来先处理。</li><li>非阻塞体现在读写数据的处理方式。<h2 id="Tomcat优化"><a href="#Tomcat优化" class="headerlink" title="Tomcat优化"></a>Tomcat优化</h2><h3 id="如何设置"><a href="#如何设置" class="headerlink" title="如何设置"></a>如何设置</h3></li><li>当连接对系统的资源占用较少，可以设置最大线程数<code>较少</code></li><li>当连接对资源占用较大，如文件和数据库读写，可以设置线程数<code>较大</code>，但不可设置太大。<h3 id="最大线程数，最大连接数，队列数"><a href="#最大线程数，最大连接数，队列数" class="headerlink" title="最大线程数，最大连接数，队列数"></a>最大线程数，最大连接数，队列数</h3></li><li>最大线程数是指多线程同时处理请求的数量,默认200</li><li>最大连接数是指同时连接着的数，包括等待中的连接。</li><li>队列数是指等待连接的数量，默认100<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h3><h4 id="Http-Code"><a href="#Http-Code" class="headerlink" title="Http Code"></a>Http Code</h4>Code | 意义 |  </li></ol><ul><li>| :-: | -:<br>301 | 重定向|<br>304 | 判断内容是否改变 |<br>401 | 未登录，授权没通过|<br>403| forbidden 接收请求，  但是资源不允许访问 |<br>405 | 方法类型错误|<br>500|服务器内部错误  |<br>503|网关错误  | </li></ul><h2 id="你遇到的问题"><a href="#你遇到的问题" class="headerlink" title="你遇到的问题"></a>你遇到的问题</h2><ol><li>https访问<code>https://www.23us.so/files/article/html/0/1/index.html</code>乱码,然后访问百度没有乱码。用http访问后就没乱码</li><li>Springboot设置最大连接数为1，两个连接都可以直接访问到，证明一个连接访问完后立刻被释放，keep-alive无效。<br>而设置其中的一个为Thread.sleep(10000)后，等到时间结束，也可以直接访问到，证明一个连接访问完后立刻被释放，keep-alive无效。<br>当连接2是在sleep时间内访问时，需要等连接1结束后过一分钟才能访问到。</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>redis介绍与开发</title>
      <link href="/2018/09/04/redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
      <url>/2018/09/04/redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>见此<a href="https://blog.csdn.net/CSDN_LQR/article/details/78108587" target="_blank" rel="noopener">链接</a></p><h2 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h2><p>redis属于非关系型数据库，基于内存进行数据的存储。</p><h2 id="redis速度为什么快"><a href="#redis速度为什么快" class="headerlink" title="redis速度为什么快"></a>redis速度为什么快</h2><ol><li>完全基于内存的存储。</li><li>IO多路复用，能支持较大的客户端连接数。</li><li>单线程处理数据，避免了线程间的切换。对于服务端来说：锁和线程切换是<code>性能杀手</code>。</li></ol><h1 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h1><h2 id="为什么redis数据结构底层要有多种实现"><a href="#为什么redis数据结构底层要有多种实现" class="headerlink" title="为什么redis数据结构底层要有多种实现"></a>为什么redis数据结构底层要有多种实现</h2><ol><li>扩展性高，类似于接口。例如redis后面添加了quicklist。</li><li>多种内部编码可以适用于不同的场景下。例如ziplist和linkedlist.</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ol><li>set  （如用于验证码的保存）</li><li>setnx 用于判断是否存在keu值，不存在返回0.（如用于<a href="http://www.importnew.com/27477.html" target="_blank" rel="noopener">redis分布式锁</a>）</li><li>exist</li></ol><h3 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h3><ol><li>int 8个字节的长整型</li><li>embstr 小于等于39个字节的字符串</li><li>raw 大于39个字节的字符串</li></ol><h1 id="redis高可用性"><a href="#redis高可用性" class="headerlink" title="redis高可用性"></a>redis高可用性</h1><h2 id="redis哨兵"><a href="#redis哨兵" class="headerlink" title="redis哨兵"></a>redis哨兵</h2><h2 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h2>]]></content>
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
